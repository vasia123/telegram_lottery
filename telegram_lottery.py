import os
import sqlite3
from dblite import aioDbLite
from pyrogram import Client
from pyrogram import filters
from pyrogram.handlers import MessageHandler
from pyrogram.types import (Message)
from pyrogram.methods.utilities.idle import idle
from pyrogram.enums import (ChatMemberStatus, ChatMembersFilter)
from pyrogram.types import BotCommand
from pyrogram.errors.exceptions.bad_request_400 import MessageNotModified
from dotenv import load_dotenv
from typing import TypedDict

load_dotenv()
API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
BOT_TOKEN = os.getenv('BOT_TOKEN')

main_text_lottery = """–†–æ–∑—ã–≥—Ä—ã—à **"[title]"** –Ω–∞—á–∞–ª—Å—è!

–ß—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ –Ω—É–∂–Ω–æ –Ω–∞–∂–∞—Ç—å –Ω–∞ `üé≤` –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ–≥–æ –≤ —á–∞—Ç.
–ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è, –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –Ω—É–∂–Ω—ã–π —ç–º–æ–¥–∑–∏ –Ω–∞–ø–∏—Å–∞–≤ –≤ –ø—É—Å—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ `dice` –∏–ª–∏ `–∫—É–±–∏–∫`, –≤ –ø–æ—è–≤–∏–≤—à–µ–π—Å—è –ø–æ–¥—Å–∫–∞–∑–∫–µ –≤—ã–±—Ä–∞—Ç—å —ç–º–æ–¥–∑–∏ –∫—É–±–∏–∫–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ —Ç–æ–ª—å–∫–æ —ç—Ç–æ—Ç —ç–º–æ–¥–∑–∏ –≤ —á–∞—Ç.

–†–æ–∑—ã–≥—Ä—ã—à –±—É–¥–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å—Å—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞—É–Ω–¥–æ–≤ —Å—Ä–µ–¥–∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Å —Å–∞–º—ã–º–∏ –≤—ã—Å–æ–∫–∏–º–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏, –ø–æ–∫–∞ –Ω–µ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –æ–¥–∏–Ω –ø–æ–±–µ–¥–∏—Ç–µ–ª—å.

–í –∫–∞–∂–¥–æ–º —Ä–∞—É–Ω–¥–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫—É–±–∏–∫.

–°—Ç–∞—Ç—É—Å: **[status]**
–†–∞—É–Ω–¥: **[round]**
–£—á–∞—Å—Ç–Ω–∏–∫–∏ —Ä–∞—É–Ω–¥–∞: 
[participants]
"""

text_winner = """
–†–æ–∑—ã–≥—Ä—ã—à **"[title]"** –æ–∫–æ—á–µ–Ω!
ü•≥ü•≥ü•≥ü•≥ü•≥ü•≥ü•≥ü•≥ü•≥

–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º **[[user_name]](tg://user?id=[user_id])** —Å –ø–æ–±–µ–¥–æ–π!!!
üéâüéâüéâüéäüéäüéäüëèüëèüëè
"""

class LotteryType(TypedDict):
    id: int
    chat_id: int
    message_id: int
    title: str
    status: int
    # dateCreated: datetime.datetime
    round: int

class ParticipantType(TypedDict):
    user_id: int
    user_name: int
    lottery_id: int
    tiket: int
    lottery_round: str
    
def get_main_message(lottery_title: str, lottery_round: int, lottery_status: str, lottery_participants: str):
    return main_text_lottery \
        .replace('[title]', lottery_title) \
        .replace('[round]', str(lottery_round)) \
        .replace('[status]', lottery_status) \
        .replace('[participants]', lottery_participants)
    
def get_winner_message(lottery_title: str, lottery_round: int, user_id: int, user_name: str):
    return text_winner \
        .replace('[title]', lottery_title) \
        .replace('[round]',  str(lottery_round)) \
        .replace('[user_id]', str(user_id)) \
        .replace('[user_name]', user_name)

def render_lottery_status(lottery_status: int, lottery_round: int):
    status = "—Ä–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω"
    if lottery_status:
        if lottery_round > 1:
            status = "–æ—Ç—Å–µ–≤ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"
        else:
            status = "–ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–∏"
    return status

class LotteryBot:
    aiodb: aioDbLite = None
    app: Client = None
        
    async def connect(self):
        """Connect to the database."""
        self.aiodb = await aioDbLite('tgbot.db')
        await self.aiodb.create(
            'lotteries', 
            id='INTEGER PRIMARY KEY AUTOINCREMENT',
            chat_id='int',
            message_id='int',
            title='TEXT NOT NULL',
            status='int(1)',
            # dateCreated='timestamp',
            round='int'
        )
        await self.aiodb.create(
            'participants', 
            id='INTEGER PRIMARY KEY AUTOINCREMENT',
            user_id='int',
            user_name='TEXT NOT NULL',
            lottery_id='int',
            tiket='int',
            lottery_round='int',
        )
        await self.aiodb.cursor.execute('CREATE UNIQUE INDEX IF NOT EXISTS "only_one_user_per_round" ON participants("user_id", "lottery_id", "lottery_round");')
        await self.app.start()
        await self.app.set_bot_commands([
            BotCommand("startlottery", "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à"),
            BotCommand("stoplottery", "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à"),
            BotCommand("nextround", "–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ —Ä–æ–∑—ã–≥—Ä—ã—à–∞")
        ])
        await idle()
        await self.app.stop()
        await self.aiodb.close()

    async def load_active_lottery(self, chat_id: int) -> LotteryType:
        lotteries_raw = await self.aiodb.select('lotteries', '*', chat_id=chat_id, status=1)
        lottery: LotteryType = {}
        if len(lotteries_raw) > 0:
            lottery = {
                "id": lotteries_raw[0][0],
                "chat_id": lotteries_raw[0][1],
                "message_id": lotteries_raw[0][2],
                "title": lotteries_raw[0][3],
                "status": lotteries_raw[0][4],
                # "dateCreated": lotteries_raw[0][5],
                "round": lotteries_raw[0][5],
            }
        return lottery

    async def load_participants(self, lottery_id: int, lottery_round: int, **kwargs) -> list[ParticipantType]:
        participants_raw = await self.aiodb.select('participants', '*', lottery_id=lottery_id, lottery_round=lottery_round, **kwargs)
        participants: list[ParticipantType] = []
        for participant_raw in participants_raw:
            participants.append({
                "id": participant_raw[0],
                "user_id": participant_raw[1],
                "user_name": participant_raw[2],
                "lottery_id": participant_raw[3],
                "tiket": participant_raw[4],
                "lottery_round": participant_raw[5],
            })
        return participants

    async def get_round_winners(self, lottery_id: int, lottery_round: int) -> list[ParticipantType]:
        participants_all = await self.load_participants(lottery_id, lottery_round)
        participants: dict[int, list[ParticipantType]] = {}
        for participant in participants_all:
            if not participant["tiket"] in participants:
                participants[participant["tiket"]] = []
            participants[participant["tiket"]].append(participant)
        winners_ticket = max(participants.keys())
        return participants[winners_ticket]

    async def set_winners_active(self, participants: list[ParticipantType], new_round: int):
        for participant in participants:
            await self.aiodb.add(
                'participants', 
                user_id=participant['user_id'],
                user_name=participant['user_name'],
                lottery_id=participant['lottery_id'],
                tiket=0,
                lottery_round=new_round,
            )


    def render_participants(self, lottery_participants: list[ParticipantType]) -> str:
        sorted_participants = sorted(lottery_participants, key=lambda d: d['tiket']) 
        participants = "    "
        if len(sorted_participants) == 0:
            participants += "__–ø–æ–∫–∞ –Ω–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤__"
        else:
            i = 0
            for participant in sorted_participants:
                tiket = participant['tiket']
                if tiket == 0:
                    tiket = "–æ–∂–∏–¥–∞–Ω–∏–µ –±—Ä–æ—Å–∫–∞"
                participants += f"[{participant['user_name']}](tg://user?id={participant['user_id']}) - **{tiket}**"
                if participants != "":
                    participants += "\n    "
                i += 1
                if i > 20:
                    participants += f"\n    ...\n    –∏ –µ—â–µ {len(sorted_participants)-i} —Å –º–µ–Ω—å—à–∏–º–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏..."
        return participants

    # start lottery
    async def startlottery_handler(self, client: Client, message: Message):
        lottery_title = message.command
        lottery_title.pop(0)
        lottery_title = ' '.join(lottery_title)
        lottery_round = 1
        lottery_status = 1
        lottery_participants = ""
        user_chat_data = await client.get_chat_member(
            chat_id=message.chat.id,
            user_id=message.from_user.id
        )
        if user_chat_data.status == ChatMemberStatus.ADMINISTRATOR or user_chat_data.status == ChatMemberStatus.OWNER:
            already_exists = await self.load_active_lottery(message.chat.id)
            if not already_exists:
                if len(lottery_title) == 0:
                    await message.reply('–ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –¥–æ–ø–∏—Å–∞–≤ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–æ–∑—ã–≥—Ä—ã—à–∞!')
                else:
                    reply_message = await client.send_message(
                        chat_id=message.chat.id,
                        text=get_main_message(
                            lottery_title,
                            lottery_round,
                            render_lottery_status(lottery_status, lottery_round),
                            lottery_participants,
                        ),
                        disable_web_page_preview=True
                    )
                    await self.aiodb.add(
                        'lotteries', 
                        chat_id=message.chat.id,
                        message_id=reply_message.id,
                        title=lottery_title,
                        status=lottery_status,
                        # dateCreated=datetime.datetime.now(),
                        round=lottery_round
                    )
                    try:
                        await client.pin_chat_message(
                            chat_id=message.chat.id,
                            message_id=reply_message.id
                        )
                    except:
                        pass
            else:
                await client.send_message(
                    chat_id=message.chat.id,
                    text='–ù–µ–ª—å–∑—è –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à –ø–æ–∫–∞ –∏–¥—ë—Ç –¥—Ä—É–≥–æ–π –∞–∫—Ç–∏–≤–Ω—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à.',
                    reply_to_message_id=already_exists['message_id']
                )
        else:
            await message.reply('–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é –ª–æ—Ç–µ—Ä–µ—é.')

    async def _stoplottery(self, client: Client, message: Message, notify_message=True):
        active_lottery = await self.load_active_lottery(message.chat.id)
        if active_lottery:
            new_status = 0
            await self.aiodb.update('lotteries', status=new_status, id=active_lottery['id'])
            if notify_message:
                await client.send_message(
                    chat_id=message.chat.id,
                    text='–†–æ–∑—ã–≥—Ä—ã—à –∑–∞–∫–æ–Ω—á–µ–Ω.',
                    reply_to_message_id=active_lottery['message_id'],
                )
            # Update message
            lottery_participants = await self.load_participants(active_lottery['id'], active_lottery['round'])
            text_participants = self.render_participants(lottery_participants)
            try:
                await client.edit_message_text(
                    chat_id=message.chat.id,
                    message_id=active_lottery['message_id'],
                    text=get_main_message(
                        active_lottery['title'],
                        active_lottery['round'],
                        render_lottery_status(new_status, active_lottery['round']),
                        text_participants,
                    ),
                    disable_web_page_preview=True,
                )
            except MessageNotModified:
                pass
            try:
                await client.unpin_chat_message(
                    chat_id=message.chat.id,
                    message_id=active_lottery['message_id']
                )
            except:
                pass
        else:
            await message.reply('–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π!')
    
    # stop lottery
    async def stoplottery_handler(self, client: Client, message: Message):
        user_chat_data = await client.get_chat_member(
            chat_id=message.chat.id,
            user_id=message.from_user.id
        )
        if user_chat_data.status == ChatMemberStatus.ADMINISTRATOR or user_chat_data.status == ChatMemberStatus.OWNER:
            await self._stoplottery(client, message)
        else:
            await message.reply('–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à.')
    
    # next round
    async def _nextround(self, client: Client, message: Message):
        active_lottery = await self.load_active_lottery(message.chat.id)
        if active_lottery:
            round_winners = await self.get_round_winners(active_lottery['id'], active_lottery['round'])
            if len(round_winners) == 1:
                await client.send_message(
                    chat_id=message.chat.id,
                    text=get_winner_message(
                        active_lottery['title'],
                        active_lottery['round'],
                        round_winners[0]['user_id'],
                        round_winners[0]['user_name'],
                    )
                )
                await self._stoplottery(client, message, False)
            else:
                new_round = active_lottery['round'] + 1
                await self.set_winners_active(round_winners, new_round)
                await message.reply('–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥!')
                # Update message
                lottery_participants = await self.load_participants(active_lottery['id'], new_round)
                text_participants = self.render_participants(lottery_participants)
                try:
                    await client.unpin_chat_message(
                        chat_id=message.chat.id,
                        message_id=active_lottery['message_id']
                    )
                except:
                    pass
                next_message = await client.send_message(
                    chat_id=message.chat.id,
                    text=get_main_message(
                        active_lottery['title'],
                        new_round,
                        render_lottery_status(active_lottery['status'], active_lottery['round']),
                        text_participants,
                    ),
                    disable_web_page_preview=True,
                )
                await self.aiodb.update('lotteries', message_id=next_message.id, round=new_round, id=active_lottery['id'])
                try:
                    await client.pin_chat_message(
                        chat_id=message.chat.id,
                        message_id=next_message.id
                    )
                except:
                    pass
        else:
            await message.reply('–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π!')

    async def nextround_handler(self, client: Client, message: Message):
        user_chat_data = await client.get_chat_member(
            chat_id=message.chat.id,
            user_id=message.from_user.id
        )
        if user_chat_data.status == ChatMemberStatus.ADMINISTRATOR or user_chat_data.status == ChatMemberStatus.OWNER:
            await self._nextround(client, message)
        else:
            await message.reply('–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –Ω–∞—á–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥.')

    async def dice_handler(self, client: Client, message: Message):
        active_lottery = await self.load_active_lottery(message.chat.id)
        if active_lottery:
            # –∑–∞—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π –±—Ä–æ—Å–æ–∫
            participants = await self.load_participants(active_lottery['id'], active_lottery['round'], user_id=message.from_user.id)
            if len(participants) == 0 or participants[0]['tiket'] == 0:
                username = message.from_user.username
                if message.from_user.first_name:
                    username = message.from_user.first_name
                    if message.from_user.last_name:
                        username += " " + message.from_user.last_name
                new_record = True
                if len(participants) > 0 and participants[0]['tiket'] == 0:
                    await self.aiodb.update(
                        'participants', 
                        user_id=message.from_user.id,
                        user_name=username,
                        lottery_id=active_lottery['id'],
                        tiket=message.dice.value,
                        lottery_round=active_lottery['round'],
                        id=participants[0]['id']
                    )
                else:
                    try:
                        await self.aiodb.add(
                            'participants', 
                            user_id=message.from_user.id,
                            user_name=username,
                            lottery_id=active_lottery['id'],
                            tiket=message.dice.value,
                            lottery_round=active_lottery['round'],
                        )
                    except sqlite3.IntegrityError:
                        new_record = False
                if new_record:
                    await message.reply(f"–†–µ–∑—É–ª—å—Ç–∞—Ç –±—Ä–æ—Å–∫–∞ (**{message.dice.value}**) –∑–∞—Å—á–∏—Ç–∞–Ω")
                # Update message
                lottery_participants = await self.load_participants(active_lottery['id'], active_lottery['round'])
                text_participants = self.render_participants(lottery_participants)
                try:
                    await client.edit_message_text(
                        chat_id=message.chat.id,
                        message_id=active_lottery['message_id'],
                        text=get_main_message(
                            active_lottery['title'],
                            active_lottery['round'],
                            render_lottery_status(active_lottery['status'], active_lottery['round']),
                            text_participants,
                        ),
                        disable_web_page_preview=True,
                    )
                except MessageNotModified:
                    pass
                # –µ—Å–ª–∏ —Ä–∞—É–Ω–¥ > 1 –∏ –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã - –Ω–∞—á–∏–Ω–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥
                if active_lottery['round'] > 1:
                    this_round_participants = await self.load_participants(active_lottery['id'], active_lottery['round'])
                    this_round_participants = [d for d in this_round_participants if d['tiket'] > 0]
                    previous_round_winners = await self.get_round_winners(active_lottery['id'], active_lottery['round'] - 1)
                    if len(this_round_participants) == len(previous_round_winners):
                        await self._nextround(client, message)

    def startBot(self):
        self.app = Client(
            "lottery_bot",
            api_id=API_ID, api_hash=API_HASH,
            bot_token=BOT_TOKEN
        )
        self.app.add_handler(MessageHandler(self.startlottery_handler, filters.command(["startlottery"])))
        self.app.add_handler(MessageHandler(self.stoplottery_handler, filters.command(["stoplottery"])))
        self.app.add_handler(MessageHandler(self.nextround_handler, filters.command(["nextround"])))
        self.app.add_handler(MessageHandler(self.dice_handler, filters.dice))
        self.app.run(self.connect())

bot = LotteryBot()
bot.startBot()
